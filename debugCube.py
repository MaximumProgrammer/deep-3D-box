import reader
import utils
import visualization as vis
from PIL import Image
import numpy as np
import cv2
import datagen
import matplotlib.pyplot as plt

# Intrinsic camera matrix
K = np.array([[7.215377e+02, 0.          , 6.095593e+02, 4.485728e+01],
              [0.          , 7.215377e+02, 1.728540e+02, 2.163791e-01],
              [0.          , 0.          , 1.          , 2.745884e-03]])

def draw_3d_box(img, coords, rot_local, rot_global, trans, color = (0, 255, 0), line_width = 2):
    """
    - Draw 3d bounding box given coords of every point
    - Assume coords generated by utils.box, transformed by 
      utils.compute_3d_coordinates, and projected by utils.project_2d
    - Parameters are self explanatory
    - This is in fact a replica of visualization.draw_3d_box with more 
      functioonality for animation such as putting text on the image
    """
    assert coords.shape == (2, 8)
    coords = coords.astype(int)
    p0 = (coords[0][0], coords[1][0])
    p1 = (coords[0][1], coords[1][1])
    p2 = (coords[0][2], coords[1][2])
    p3 = (coords[0][3], coords[1][3])
    p4 = (coords[0][4], coords[1][4])
    p5 = (coords[0][5], coords[1][5])
    p6 = (coords[0][6], coords[1][6])
    p7 = (coords[0][7], coords[1][7])
    
    lines = [
         (p0, p1),
         (p0, p5),
         (p0, p7),
         (p1, p2),
         (p1, p4),
         (p2, p3),
         (p2, p7), 
         (p3, p6), 
         (p3, p4), 
         (p4, p5), 
         (p5, p6), 
         (p6, p7)
    ]

    colors = [
        (255, 0, 0),
        (0, 0, 255),
        (0, 255, 0),
        (255, 255, 0)
    ]
    
    xmin_idx, ymin_idx = np.argmin(coords, axis = -1)
    xmax_idx, ymax_idx = np.argmax(coords, axis = -1)
    # draw lines
    for p1, p2 in lines:
        cv2.line(img, p1, p2, color, line_width)
    # draw points
    for i in range(8):
        x, y = coords[0][i], coords[1][i] 
        
        if i in [0]:
            color = (255, 0, 0)
        elif i in [1, 2]:
            color = (0, i * 50 ,  i * 50)
        elif i in [5]:
            color = (0, 0, 255 )
        else:
            color = (100, 100, 100)
        # cv2.circle(img, (x, y), 1, color, 3)
        # draw secind circle indicating xmin, xmax ymin and ymax
        if i == xmin_idx:
            color = (80, 0, 0)
            cv2.circle(img, (x, y), 3, color, 4)
        if i == ymin_idx:
            color = (0, 0, 80)
            cv2.circle(img, (x, y), 3, color, 4)
        if i == xmax_idx:
            color = (255, 0, 0)
            cv2.circle(img, (x, y), 6, color, 8)
        if i == ymax_idx:
            color = (0, 0, 255)
            cv2.circle(img, (x, y), 6, color, 8)
        
        txt_1 = "Rot global : %.2f"%(rot_global*180/np.pi)
        cv2.putText(img,txt_1,(10,25), cv2.FONT_HERSHEY_SIMPLEX, 0.4,(255,255,255),1,cv2.LINE_AA)
        txt_2 = "xmin, ymin, xmax, ymax : %i, %i, %i, %i"%\
                                                (xmin_idx, ymin_idx, xmax_idx, ymax_idx)
        cv2.putText(img,txt_2,(10,40), cv2.FONT_HERSHEY_SIMPLEX, 0.4,(255,255,255),1,cv2.LINE_AA)
        txt_3 = "Rot local : %.2f"%(rot_local*180/np.pi)
        cv2.putText(img,txt_3,(10,55), cv2.FONT_HERSHEY_SIMPLEX, 0.4,(255,255,255),1,cv2.LINE_AA)
        n_bins = 4
        bins = [i * 2 * np.pi / n_bins for i in range(n_bins+1)]
        hist, _ = np.histogram(a=rot_local, bins = bins)
        rot_range = bins[np.argmax(hist)], bins[np.argmax(hist)+1]
        txt_4 = "Global rotation range : %.2f, %.2f"%(rot_range[0] * 180 / np.pi, rot_range[1] * 180 / np.pi)
        cv2.putText(img,txt_4,(10,70), cv2.FONT_HERSHEY_SIMPLEX, 0.4,(255,255,255),1,cv2.LINE_AA)
        txt_5 = "Translation vector : %s"%str(trans)
        cv2.putText(img,txt_5,(10,85), cv2.FONT_HERSHEY_SIMPLEX, 0.4,(255,255,255),1,cv2.LINE_AA)

def get_angle(i):
    """
    Generate angle with given index
    """
    # angle = (i * np.pi / 360) % (np.pi * 2) 
    angle = 3 * np.pi / 2
    return angle

def get_trans(i):
    """
    Generate translation vector with given index
    """    
    x = (i * 6 % 1200) / 50 - 12 # left
    z = 30
    return np.array([x, 1, z])

def get_bbox(i, width = 1300, height = 325):    
    """
    Generate bounding box with given index. Perhaps moving 
    """
    # bbox = (i * 2 % (width - 200)), 200, (i * 2 % (width - 200)) + 200, 250 # moving box
    # bbox = int(width/3), int(height/3), int(width/ 2), int(height/2) # center
    bbox = 500, 170, 550, 210
    return bbox


# Define variables of use
dims = np.array([1.5, 1.5, 4.5])
i = 0

# Iterate and visualize 
while True:
    img = np.zeros((325, 1300, 3))    
    alpha = get_angle(i)
    bbox = get_bbox(i, width = img.shape[1], height = img.shape[0])
    rot_global = utils.compute_orientation(K = K, angle=alpha, bbox_2d=bbox)
    trans = utils.solve_for_translations(K, dims, alpha, rot_global, bbox)
    cv2.rectangle(img, tuple(bbox[:2]), tuple(bbox[2:]), (255, 0, 0), 4)
    coords_3d = utils.compute_3d_coordinates(K,
                                        trans, 
                                        alpha, 
                                        dims, 
                                        bbox)
    coords_2d = utils.project_2d(K, coords_3d)
    draw_3d_box(img, coords_2d, alpha, rot_global, trans)
    
    cv2.imshow('image', img)
    cv2.waitKey(1)
    i += 1
